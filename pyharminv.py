#! /usr/bin/env python
# -*- coding: utf-8 -*-
# little module to read in data from harminv and return it as a list
# of resonances with their corresponding decay constants, Qs, amplitudes, phases, and errors
# KJR 17 Nov 2009
import numpy
import pylab
import pyLumerical
import os

# A harminv output file will look something like this:
## frequency, decay constant, Q, amplitude, phase, error
## -0.306685, 1.181439e-02, 81.5514, 270.241, -2.7881, 4.379371e-06
## 0.306686, 1.198144e-02, 80.4146, 273.913, 2.78836, 8.313238e-06
## 0.401071, 1.279775e-02, 98.455, 94.6862, 1.60337, 1.143150e-05

def read(fname): 
    """This is a simple function (just loads in the file 'fname' that was generated by harminv),
    but this will save me from looking it up all the time..."""
    try:
        with open( fname, 'r' ) as fileobject:
            line = fileobject.readline()
            # assume there's a header
            skiplines = 1
            for line in fileobject:
                if line[0] not in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']:
                    skiplines += 1
                else:
                    break

            return numpy.loadtxt( fname, delimiter=',', skiprows=skiplines,dtype='float' )
    except IOError:
        print "The harminv file is empty; probably it didn't encounter any resonances."
        return None

def allfields(fname): 
    """Read in the harminvout file 'fname' and break the records into pieces according to element:
    (frequency, decay constant, Q, amplitude, phase, and error)."""
    harminv = read(fname)
    if harminv is None: 
        return [None]*6
    
    if len(harminv.shape) ==1 :
        return (numpy.array(harminv[0]), numpy.array(harminv[1]), numpy.array(harminv[2]),
                numpy.array(harminv[3]), numpy.array(harminv[4]), numpy.array(harminv[5]))
        
    f=numpy.zeros(harminv.shape[0]); alpha=numpy.zeros(harminv.shape[0]); Q=numpy.zeros(harminv.shape[0]); 
    amp=numpy.zeros(harminv.shape[0]); phase=numpy.zeros(harminv.shape[0]); error=numpy.zeros(harminv.shape[0]); 
    for i in range(harminv.shape[0]):
        f[i] = harminv[i][0]
        alpha[i] = harminv[i][1]
        Q[i] = harminv[i][2]
        amp[i] = harminv[i][3]
        phase[i] = harminv[i][4]
        error[i] = harminv[i][5]
    return (f,alpha,Q,amp,phase,error)
     
def fandQ(fname):
    """
    Read in the harminvout file 'fname' and return only the 
    frequency f and the Q-factor Q for each resonance found.
    Returns None if none were found.
    """
    data = allfields(fname)
    if data is None: return (None, None)
    f,alpha,Q,amp,phase,error = data
    return (f,Q)
    
def fandQ_OnlyPositivef(fname):
    """
    Read in the harminvout file 'fname' and return only the 
    frequency f and the Q-factor Q for each resonance found that has positive frequency.
    Returns None if no resonances were found.
    """
    data = allfields(fname)
    if data is None: return (None, None)
    f,alpha,Q,amp,phase,error = data
    if f.size == 1:
        return f, Q
    fpos = f[pylab.find(f>0.0)]
    Qpos = Q[pylab.find(f>0.0)]
    return (fpos,Qpos)

def runHarminv( filename, wavelength_low=600.0, wavelength_high=1200.0, error="1e-4", tSrcEnd=35.0, getallfields=True, verbose=True ):
    """
    Read in a Lumerical time series and analyze it with harminv. This function will save a temporary
    file in the current directory called harminvIn that it will use to pass the data to harminv, and
    output from harminv will be stored in the file harminvOut
    Example usage: ::

        wavelength, Q = runHarminv( fname, wavelength_low=600.0, wavelength_high=1200.0, tSrcEnd=35.0, getallfields=False )


    or ::
    
        wavelength,alpha,Q,amp,phase,error = runHarminv(
            fname,
            wavelength_low=600.0,
            wavelength_high=1200.0,
            tSrcEnd=35.0,
            getallfields=True )

    where the specified wavelength limits are in nm (assuming the time series data is in fs)
    """
    d = pyLumerical.load1D_timeseries( filename )
    tfs = d[:,0]
    dt = tfs[2]-tfs[1]
    field = d[:,1]
    ringdown = field[ pylab.find( tfs>tSrcEnd )]
    numpy.savetxt( 'harminvIn', ringdown )
    df = "%.4f-%.4f" % ( 300.0/wavelength_high, 300.0/wavelength_low ) # frequency range of interest (PHz, because dt is in fs)
    harminvOutfile = "harminvOut"
    cmd = "harminv -E " + error + " -t "+str(dt)+" "+df+" < harminvIn > "+harminvOutfile
    print cmd
    os.system(cmd)
    
    # read in the Harminv output file to recover f and Q and plot them
    if getallfields == False:
        fres,Q = fandQ_OnlyPositivef( harminvOutfile )
        if fres is not None:
            print 300.0/fres # convert to wavelength
            print Q
            return 300.0/fres, Q
        else:
            return fres,Q    
    else:
        f,alpha,Q,amp,phase,error = allfields( harminvOutfile )
        if f is None:
            return [None]*6
        else:
            return f,alpha,Q,amp,phase,error

